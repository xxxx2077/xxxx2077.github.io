# MySQL

## 锁

### 全局锁

用于全局逻辑备份， 避免因为数据的更新导致备份文件的数据与预期的不一样

缺点：整个数据都是只读状态

避免方式：备份数据库前开启事务，在MVCC支持下，该事务执行期间都在使用这个Read View，其他事务能够继续更新数据，互不影响

### 表级锁

#### 表锁

- 共享锁（读）
- 独占锁（写）

加了共享表锁，之后执行写操作会被阻塞

#### 元数组锁（MDL）

- 对一张表进行CRUD，加MDL读锁
- 对一张表表结构进行修改，加MDL写锁

申请MDL锁会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现MDL写锁阻塞，会阻塞其他读锁，从而阻塞其他CRUD操作

为了安全对表进行变更，表结构变更前，先看看数据库中的长事务是否加了MDL读锁，可以考虑kill掉这个长事务再做表结构的变更

#### 意向锁

**意向锁是为了快速判断表里是否有记录被加锁**

如果没有意向锁，加独占表锁时，需要遍历所有记录，看是否存在独占锁

- 对某条记录加上共享表锁之前，先要加上表级意向共享锁
- 对某条记录加上独占表锁之前，先要加上表级意向独占锁

#### AUTO-INC 锁

该锁保证主键递增

插入数据时加上AUTO-INC锁，执行完插入语句后立即释放

大量插入语句时会导致阻塞

有轻量级锁，保证更新完主键值立刻释放，不需要等插入语句执行完

#### 行级锁

普通select是快照读

select for update（加独占锁）和select ... lock in share mode（加共享锁）是锁定读，锁定读需要在事务中进行

##### 记录锁

锁一条记录，也是分为共享锁(S)和独占锁(X)

##### 间隙锁

解决可重复读隔离级别下的幻读

加上间隙锁后，其他事务无法在该范围插入数据，避免了幻读

两个事务可同时持有包含共同间隙范围的间隙锁

##### Next-key lock

记录锁 + 间隙锁

锁定记录（记录锁） + 锁定范围（间隙锁）

即不能插入数据，也不能更新数据

两个事务不能同时拥有同一范围的X型的Next-key lock

#### 插入意向锁

不是意向锁，是特殊的间隙锁（锁住某个点），是行级别锁

当某个范围被加上了间隙锁，某事务想要在该范围插入数据，需要等待，即阻塞。

这时候会给他分配一个插入意向锁，表示处于插入等待状态

插入意向锁的作用在于：多个事务想往间隙锁所在区间插入数据会阻塞，而获得插入意向锁后事务之间不会阻塞（只要插入的不是同一个地方）