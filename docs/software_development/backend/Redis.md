## Redis

### Redis底层的数据类型

#### string

##### 原理

底层使用了SDS（简单动态字符串）

使用len记录字符串的长度，而不是通过'\0'判断字符串结尾

- 不仅可以保存文本数据，还可以保存二进制数据（如视频、文件等）
- 获取字符串长度的时间复杂度为O(1)
- Redis字符串的API是安全的，拼接字符串不会造成缓冲区溢出（会自动扩容）

##### 应用

- 缓存对象
- 常规计数（Redis执行命令是单线程原子操作）
- 分布式锁
  - 利用SETNX命令，key不存在时才插入
    - 如果key不存在，则显示插入成功，对应加锁成功
    - 如果key存在，则显示插入失败，对应加锁失败
  - 使用EX命令设置锁的过期时间，防止死锁
  - 使用Lua脚本（Redis执行Lua脚本时可以以原子的方式执行）保证锁释放操作的原子性
- 共享session信息

#### list

##### 原理

底层使用双向链表或压缩列表实现

Redis3.2版本之后使用quicklist

##### 应用

消息队列

- 先进先出：LPUSH + RPOP or RPUSH + LPOP
  - 消费者无法得知生产者有新数据产生，使用RPOP或LPOP需要循环阻塞
  - **使用BRPOP非阻塞式读取，没读到数据自动阻塞，有新数据进入读到数据就返回，节省CPU开销**
- 处理重复消息
  - 每个消息需要有一个全局ID
  - 消费者需要记录已经处理过的消息ID，与当前收到的消息ID比对，如果处理过无需再处理
  - **我们需要自行为每条消息生成一个全局唯一ID**
- 保证消息可靠性
  - 消费者从List读取一条消息后，List不再存有这条消息，若消费者处理过程因为故障或其他原因丢失这条消息，则消费者程序再次启动时，就没法从List读取这条消息
  - 使用BRPOPLPUSH命令，消费者程序从一个List读取消息，同时将这条消息插入到备份List中留存
  - 若丢失消息可以从备份List中读取

缺点：

不支持多个消费者消费同一条消息，消费完一条消息，这条消息就从List中删去

想要实现多个消费者消费同一条消息，需要实现消费组，List不支持消费组的实现

而Stream类型可以

#### hash

##### 原理

压缩列表或哈希表

Redis7.0由listpack实现

##### 应用

缓存对象

String + Json 和 Hash都能缓存对象

一般使用String + Json 

变动频繁使用Hash

- 购物车，key对应用户id，field对应商品id，value对应商品数量

#### set

哈希表或整数集合

##### 应用

适合数据去重和保证数据的唯一性

适合统计多个集合的交集、错集和并集等

- 计算复杂度较高，避免主库阻塞，交给从库或客户端计算

点赞功能（一个用户只能点一个赞）

共同关注（交集运算）

抽奖活动（一个用户只能中一次奖）

#### zset

压缩列表 or 跳表

Redis7.0压缩列表废弃，交给listpack

在set基础上添加了score，score可以重复，value不能重复，通过score排序

##### 应用

排行榜

